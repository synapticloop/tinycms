package com.synapticloop.tinycms.sqlite.h2zero.model;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//                  (java-create-model.templar)

import com.synapticloop.h2zero.base.manager.sqlite3.ConnectionManager;
import com.synapticloop.h2zero.base.validator.bean.ValidationBean;
import com.synapticloop.h2zero.base.validator.bean.ValidationFieldBean;
import com.synapticloop.tinycms.sqlite.h2zero.question.CollectionQuestion;
import com.synapticloop.h2zero.base.validator.*;
import com.synapticloop.h2zero.base.model.sqlite3.ModelBase;
import com.synapticloop.h2zero.base.exception.H2ZeroPrimaryKeyException;
import com.synapticloop.h2zero.base.exception.H2ZeroFinderException;
import java.lang.StringBuilder;
import java.sql.Connection;
import java.math.BigDecimal;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import org.json.JSONObject;
import com.synapticloop.h2zero.util.XmlHelper;

import com.synapticloop.h2zero.base.model.ModelBaseHelper;
import com.synapticloop.tinycms.sqlite.h2zero.model.util.Constants;

import com.synapticloop.tinycms.sqlite.h2zero.finder.DataCollectionFinder;
import com.synapticloop.tinycms.sqlite.h2zero.finder.CollectionFinder;


/**
 * <p>This is the model for the <code>DataCollection</code> which maps to the <code>data_collection</code> database table.</p>
 * <p>This class contains all CRUD (Create, Read, Update, and Delete) methods.</p>
  * 
 * @author synapticloop h2zero
 * 
 * <p>@see <a href="https://github.com/synapticloop/h2zero">Synapticloop h2zero GitHub repository</a></p>
 */
public class DataCollection extends ModelBase {
	// the binder is unused in code, but will generate compile problems if this 
	// class is no longer referenced in the h2zero file. Just a nicety for
	// removing dead code
	@SuppressWarnings("unused")
	private static final String BINDER = Constants.DATA_COLLECTION_BINDER;


	public static final String PRIMARY_KEY_FIELD = "id_data_collection";  // the primary key - a convenience field

	private static final String SQL_INSERT = 
		"""
			insert into
			data_collection (
				id_collection,
				nm_collection,
				fl_is_published
			) values (
				?,
				?,
				?
			)
		""";
	private static final String SQL_UPDATE = 
		"""
			update
				data_collection
			set
				id_collection = ?,
				nm_collection = ?,
				fl_is_published = ?
			where
		"""
			+ PRIMARY_KEY_FIELD + 
		"""
			= ?
		""";
	private static final String SQL_DELETE = "delete from data_collection where " + PRIMARY_KEY_FIELD + " = ?";
	private static final String SQL_ENSURE = "select " + PRIMARY_KEY_FIELD + " from data_collection where id_collection = ? and nm_collection = ? and fl_is_published = ?";


	// Static lookups for fields in the hit counter.
	// Whilst these aren't used internally (the offset to the array is 
	// automatically computer, external classes can use these static fields 
	// to look up the hit counts in the array 
	public static final int HIT_TOTAL = 0;
	public static final int HIT_ID_DATA_COLLECTION = 1;
	public static final int HIT_ID_COLLECTION = 2;
	public static final int HIT_NM_COLLECTION = 3;
	public static final int HIT_FL_IS_PUBLISHED = 4;


	// the list of fields for the hit - starting with 'TOTAL'
	private static final String[] HIT_FIELDS = { "TOTAL", "id_data_collection", "id_collection", "nm_collection", "fl_is_published" };
	// the number of read-hits for a particular field
	private static final int[] HIT_COUNTS = { 0, 0, 0, 0, 0 };

	private Collection Collection = null; // maps to the id_collection field

	private Long idDataCollection = null; // maps to the id_data_collection field
	private Long idCollection = null; // maps to the id_collection field
	private String nmCollection = null; // maps to the nm_collection field
	private Boolean flIsPublished = null; // maps to the fl_is_published field

	public DataCollection(Long idDataCollection, Long idCollection, String nmCollection, Boolean flIsPublished) {
		this.idDataCollection = idDataCollection;
		this.idCollection = idCollection;
		this.nmCollection = nmCollection;
		this.flIsPublished = flIsPublished;
	}

	/**
	 * <p>Get a new DataCollection model, or set the fields on an existing
	 * DataCollection model.</p>
	 * 
	 * <p>If the passed in dataCollection is null, then a new DataCollection
	 * will be created.  If not null, the fields will be updated on the passed in model.</p>
	 * 
	 * <p><strong>NOTE:</strong> You will still need to persist this to the database
	 * with an <code>upsert()</code> call - this will insert the model if it .
	 * doesn't exist, or update the existing model.</p>
	 * 
	 * @param dataCollection the model to check
	 * @param idCollection - maps to the <code>id_collection</code> field.
	 * @param nmCollection - maps to the <code>nm_collection</code> field.
	 * @param flIsPublished - maps to the <code>fl_is_published</code> field.
	 * 
	 * @return Either the existing dataCollection with updated field values,
	 *   or a new DataCollection with the field values set.
	 */
	public static DataCollection getOrSet(DataCollection dataCollection,Long idCollection, String nmCollection, Boolean flIsPublished) {
		if(null == dataCollection) {
			return (new DataCollection(null, idCollection, nmCollection, flIsPublished));
		} else {
			dataCollection.setIdCollection(idCollection);
			dataCollection.setNmCollection(nmCollection);
			dataCollection.setFlIsPublished(flIsPublished);

			return(dataCollection);
		}
	}

	@Override
	public boolean primaryKeySet() {
		return(null != idDataCollection);
	}


	@Override
	public void insert(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {
		if(primaryKeySet()) {
			throw new H2ZeroPrimaryKeyException("Cannot insert data_collection model when primary key is not null.");
		}

		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		try {
			// create this bean 
			preparedStatement = connection.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);
			ConnectionManager.setBigint(preparedStatement, 1, idCollection);
			ConnectionManager.setVarchar(preparedStatement, 2, nmCollection);
			ConnectionManager.setBoolean(preparedStatement, 3, flIsPublished);
			preparedStatement.executeUpdate();
			resultSet = preparedStatement.getGeneratedKeys();
			if(resultSet.next()) {
				this.idDataCollection = resultSet.getLong(1);
			} else {
				throw new H2ZeroPrimaryKeyException("Could not get return value for primary key!");
			}
		} finally {
			ConnectionManager.closeAll(resultSet, preparedStatement);
		}
	}

	@Override
	public void ensure(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {

		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		try {
			preparedStatement = connection.prepareStatement(SQL_ENSURE);
			ConnectionManager.setBigint(preparedStatement, 1, idCollection);
			ConnectionManager.setVarchar(preparedStatement, 2, nmCollection);
			ConnectionManager.setBoolean(preparedStatement, 3, flIsPublished);
			resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) {
				this.idDataCollection = resultSet.getLong(1);
			} else {
				// could not find the value - need to insert it - null is the primary key
				insert(connection);
			}
		} finally {
			ConnectionManager.closeAll(resultSet, preparedStatement);
		}
	}

	@Override
	public void update(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {
		if(!primaryKeySet()) {
			throw new H2ZeroPrimaryKeyException("Cannot update bean when primary key is null.");
		}

		if(isDirty) {
			try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_UPDATE)) {
				// update this bean, but only if dirty
				ConnectionManager.setBigint(preparedStatement, 1, idCollection);
				ConnectionManager.setVarchar(preparedStatement, 2, nmCollection);
				ConnectionManager.setBoolean(preparedStatement, 3, flIsPublished);
				// now set the primary key
				preparedStatement.setLong(4, idDataCollection);
				preparedStatement.executeUpdate();
			} finally {
				isDirty = false;
			}
		}
	}

	@Override
	public void delete(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {
		if(!primaryKeySet()) {
			throw new H2ZeroPrimaryKeyException("Cannot delete bean when primary key is null.");
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_DELETE)) {
			preparedStatement.setLong(1, idDataCollection);
			preparedStatement.executeUpdate();
		}
	}

	@Override
	public void refresh(Connection connection) throws SQLException, H2ZeroPrimaryKeyException, H2ZeroFinderException {
		if(!primaryKeySet()) {
			throw new H2ZeroPrimaryKeyException("Cannot refresh model 'DataCollection' when primary key is null.");
		}

		DataCollection dataCollection = DataCollectionFinder.findByPrimaryKeySilent(connection, this.idDataCollection);
		if(null == dataCollection) {
			throw new H2ZeroFinderException("Could not find the model 'DataCollection' with primaryKey of " + getPrimaryKey());
		}
		this.idDataCollection = dataCollection.getIdDataCollection();
		this.idCollection = dataCollection.getIdCollection();
		this.nmCollection = dataCollection.getNmCollection();
		this.flIsPublished = dataCollection.getFlIsPublished();
		this.Collection = null;
	}

	public static String[] getHitFields() { return(HIT_FIELDS); }
	public static int[] getHitCounts() { return(HIT_COUNTS); }

	/**
	 * Get the hit count for a specific field - look at the <code>public static HIT_*</code>
	 * fields to retrieve a specific field.
	 *
	 * @param hitCountField the hit count field number to retrieve the hit count from
	 *
	 * @return the hit count for the field
	 * 
	 * <p>{@link #HIT_ID_DATA_COLLECTION Use <code>DataCollection.HIT_ID_DATA_COLLECTION</code> to retrieve the hit count for the <code>id_data_collection</code> field}</p>
	 * <p>{@link #HIT_ID_COLLECTION Use <code>DataCollection.HIT_ID_COLLECTION</code> to retrieve the hit count for the <code>id_collection</code> field}</p>
	 * <p>{@link #HIT_NM_COLLECTION Use <code>DataCollection.HIT_NM_COLLECTION</code> to retrieve the hit count for the <code>nm_collection</code> field}</p>
	 * <p>{@link #HIT_FL_IS_PUBLISHED Use <code>DataCollection.HIT_FL_IS_PUBLISHED</code> to retrieve the hit count for the <code>fl_is_published</code> field}</p>

	 */
	public static int getHitCountForField(int hitCountField) { return(HIT_COUNTS[hitCountField]); }

	public Collection getCollection() {
		if(null == this.Collection) {
			this.Collection = CollectionFinder.findByPrimaryKeySilent(this.idCollection);
		}
		return(this.Collection);
	}

	public static void updateHitCount(int offset) {
		HIT_COUNTS[0]++;
		HIT_COUNTS[offset]++;
	}

	/*
	 * Boring ol' getters and setters 
	 * 
	 * On setting any of these fields - the 'isDirty' flag will be set
	 * 
	 */

	public Long getPrimaryKey() { updateHitCount(1); return(this.idDataCollection); }
	public void setPrimaryKey(Long idDataCollection) { if(isDifferent(this.idDataCollection, idDataCollection)) { this.idDataCollection = idDataCollection;this.isDirty = true; }}
	public Long getIdDataCollection() { updateHitCount(1); return(this.idDataCollection); }
	public void setIdDataCollection(Long idDataCollection) { if(isDifferent(this.idDataCollection, idDataCollection)) { this.idDataCollection = idDataCollection;this.isDirty = true; }}
	public Long getIdCollection() { updateHitCount(2); return(this.idCollection); }
	public void setIdCollection(Long idCollection) { if(isDifferent(this.idCollection, idCollection)) { this.idCollection = idCollection;this.isDirty = true; this.Collection = null;}}
	public String getNmCollection() { updateHitCount(3); return(this.nmCollection); }
	public void setNmCollection(String nmCollection) { if(isDifferent(this.nmCollection, nmCollection)) { this.nmCollection = nmCollection;this.isDirty = true; }}
	public Boolean getFlIsPublished() { updateHitCount(4); return(this.flIsPublished); }
	public void setFlIsPublished(Boolean flIsPublished) { if(isDifferent(this.flIsPublished, flIsPublished)) { this.flIsPublished = flIsPublished;this.isDirty = true; }}

	@Override
	public ValidationBean validate() {
		ValidationBean validationBean = new ValidationBean();

		ValidationFieldBean idCollectionValidationFieldBean = new BigintValidator("id_collection", idCollection.toString(), 0, 0, false).validate();
		idCollectionValidationFieldBean.setIsIncorrectForeignKey(!CollectionQuestion.internalDoesPrimaryKeyExist(idCollection));
		validationBean.addValidationFieldBean(idCollectionValidationFieldBean);

		validationBean.addValidationFieldBean(new VarcharValidator("nm_collection", nmCollection.toString(), 0, 256, false).validate());
		validationBean.addValidationFieldBean(new BooleanValidator("fl_is_published", flIsPublished.toString(), 0, 0, false).validate());
		return(validationBean);
	}


	@Override
	public String toString() {
		return(
			"{\"DataCollection\": {" +
			"\"idDataCollection\":\"" + this.idDataCollection + "\"" +
			"\"idCollection\":\"" + this.idCollection + "\"" +
			"\"nmCollection\":\"" + this.nmCollection + "\"" +
			"\"flIsPublished\":\"" + this.flIsPublished + "\"" +
			"}");
	}
	public JSONObject getToJSON() {
		return(toJSON());
	}

	public JSONObject toJSON() {
		JSONObject jsonObject = new JSONObject();

		jsonObject.put("type", "table");
		jsonObject.put("name", "DataCollection");
		JSONObject fieldsObject = new JSONObject();

		ModelBaseHelper.addtoJSONObject(fieldsObject, "idDataCollection", this.getIdDataCollection());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "idCollection", this.getIdCollection());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "nmCollection", this.getNmCollection());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "flIsPublished", this.getFlIsPublished());

		jsonObject.put("fields", fieldsObject);

		return(jsonObject);
	}


	public String toJsonString() {
		return(toJSON().toString());
	}

	public String getJsonString() {
		return(toJsonString());
	}

	/**
	 * <p>Return an XML representation of the <code>DataCollection</code> model as a <code>String</code>, 
	 * with the root node being the name of the table - i.e. <code>&lt;data_collection /&gt;</code> 
	 * and the child nodes the name of the fields.</p>
	 * 
	 * <p><strong>NOTE:</strong> Any field marked as secure will not be included as
	 * part of the XML document</p>
	 * 
	 * @return An XML representation of the model as a <code>String</code>.
	 */
	public String toXMLString() {
		return("<data_collection>" + 
			String.format("<id_data_collection null=\"%b\">%s</id_data_collection>", (this.getIdDataCollection() == null), (this.getIdDataCollection() != null ? this.getIdDataCollection() : "")) + 
			String.format("<id_collection null=\"%b\">%s</id_collection>", (this.getIdCollection() == null), (this.getIdCollection() != null ? this.getIdCollection() : "")) + 
			String.format("<nm_collection null=\"%b\">%s</nm_collection>", (this.getNmCollection() == null), (this.getNmCollection() != null ? XmlHelper.escapeXml(this.getNmCollection()) : "")) + 
			String.format("<fl_is_published null=\"%b\">%s</fl_is_published>", (this.getFlIsPublished() == null), (this.getFlIsPublished() != null ? this.getFlIsPublished() : "")) + 
			"</data_collection>");
	}


	/**
	 * Get the hit count statistics as a JSON encoded object as a <code>String</code>.
	 *
	 * @return the JSON Object as a <code>String</code>.
	 */
	public static String getHitCountJson() {
		JSONObject jsonObject = new JSONObject();
		jsonObject.put("type", "DataCollection");
		jsonObject.put("total", HIT_COUNTS[0]);
		jsonObject.put("idDataCollection", HIT_COUNTS[1]);
		jsonObject.put("idCollection", HIT_COUNTS[2]);
		jsonObject.put("nmCollection", HIT_COUNTS[3]);
		jsonObject.put("flIsPublished", HIT_COUNTS[4]);
		return(jsonObject.toString());
	}

}