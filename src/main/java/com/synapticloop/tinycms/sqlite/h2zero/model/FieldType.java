package com.synapticloop.tinycms.sqlite.h2zero.model;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//                  (java-create-model.templar)

import java.util.HashMap;

import java.util.Map;


import org.json.JSONObject;
import com.synapticloop.h2zero.util.XmlHelper;

import com.synapticloop.h2zero.base.model.ModelBaseHelper;
import com.synapticloop.tinycms.sqlite.h2zero.model.util.Constants;


/**
 * <p>This is the model for the <code>FieldType</code> which maps to the <code>field_type</code> database table.</p>
 * <p><strong>NOTE:</strong> This is a constant table which cannot be changed and no CRUD methods are available.</p>
  * 
 * @author synapticloop h2zero
 * 
 * <p>@see <a href="https://github.com/synapticloop/h2zero">Synapticloop h2zero GitHub repository</a></p>
 */
public class FieldType  {
	// the binder is unused in code, but will generate compile problems if this 
	// class is no longer referenced in the h2zero file. Just a nicety for
	// removing dead code
	@SuppressWarnings("unused")
	private static final String BINDER = Constants.FIELD_TYPE_BINDER;

	public static final FieldType STRING = new FieldType(Long.valueOf(1), "string", Boolean.valueOf("1"));
	public static final FieldType TEXT = new FieldType(Long.valueOf(2), "text", Boolean.valueOf("1"));
	public static final FieldType INTEGER = new FieldType(Long.valueOf(3), "integer", Boolean.valueOf("0"));
	public static final FieldType FLOAT = new FieldType(Long.valueOf(4), "float", Boolean.valueOf("0"));
	public static final FieldType BOOLEAN = new FieldType(Long.valueOf(5), "boolean", Boolean.valueOf("0"));
	public static final FieldType MEDIA = new FieldType(Long.valueOf(6), "media", Boolean.valueOf("1"));
 	public static final Long STRING_PRIMARY_KEY_VALUE = Long.valueOf(1);
 	public static final Long TEXT_PRIMARY_KEY_VALUE = Long.valueOf(2);
 	public static final Long INTEGER_PRIMARY_KEY_VALUE = Long.valueOf(3);
 	public static final Long FLOAT_PRIMARY_KEY_VALUE = Long.valueOf(4);
 	public static final Long BOOLEAN_PRIMARY_KEY_VALUE = Long.valueOf(5);
 	public static final Long MEDIA_PRIMARY_KEY_VALUE = Long.valueOf(6);

	public static final FieldType[] ALL =  {
		FieldType.STRING, FieldType.TEXT, FieldType.INTEGER, FieldType.FLOAT, FieldType.BOOLEAN, FieldType.MEDIA
	};

	public static final Map<Long, FieldType> ALL_LOOKUP = new HashMap<>();
	static{
		ALL_LOOKUP.put(Long.valueOf(1), FieldType.STRING);
		ALL_LOOKUP.put(Long.valueOf(2), FieldType.TEXT);
		ALL_LOOKUP.put(Long.valueOf(3), FieldType.INTEGER);
		ALL_LOOKUP.put(Long.valueOf(4), FieldType.FLOAT);
		ALL_LOOKUP.put(Long.valueOf(5), FieldType.BOOLEAN);
		ALL_LOOKUP.put(Long.valueOf(6), FieldType.MEDIA);

	};


	public static final String PRIMARY_KEY_FIELD = "id_field_type";  // the primary key - a convenience field



	private Long idFieldType = null; // maps to the id_field_type field
	private String nmFieldType = null; // maps to the nm_field_type field
	private Boolean flFieldShouldQuote = null; // maps to the fl_field_should_quote field

	public FieldType(Long idFieldType, String nmFieldType, Boolean flFieldShouldQuote) {
		this.idFieldType = idFieldType;
		this.nmFieldType = nmFieldType;
		this.flFieldShouldQuote = flFieldShouldQuote;
	}

	/*
	 * Boring ol' getters and setters 
	 * 
	 * On setting any of these fields - the 'isDirty' flag will be set
	 * 
	 */

	public Long getPrimaryKey() { return(this.idFieldType); }
	public Long getIdFieldType() { return(this.idFieldType); }
	public String getNmFieldType() { return(this.nmFieldType); }
	public Boolean getFlFieldShouldQuote() { return(this.flFieldShouldQuote); }

	@Override
	public String toString() {
		return(
			"{\"FieldType\": {" +
			"\"idFieldType\":\"" + this.idFieldType + "\"" +
			"\"nmFieldType\":\"" + this.nmFieldType + "\"" +
			"\"flFieldShouldQuote\":\"" + this.flFieldShouldQuote + "\"" +
			"}");
	}
	public JSONObject getToJSON() {
		return(toJSON());
	}

	public JSONObject toJSON() {
		JSONObject jsonObject = new JSONObject();

		jsonObject.put("type", "table");
		jsonObject.put("name", "FieldType");
		JSONObject fieldsObject = new JSONObject();

		ModelBaseHelper.addtoJSONObject(fieldsObject, "idFieldType", this.getIdFieldType());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "nmFieldType", this.getNmFieldType());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "flFieldShouldQuote", this.getFlFieldShouldQuote());

		jsonObject.put("fields", fieldsObject);

		return(jsonObject);
	}


	public String toJsonString() {
		return(toJSON().toString());
	}

	public String getJsonString() {
		return(toJsonString());
	}

	/**
	 * <p>Return an XML representation of the <code>FieldType</code> model as a <code>String</code>, 
	 * with the root node being the name of the table - i.e. <code>&lt;field_type /&gt;</code> 
	 * and the child nodes the name of the fields.</p>
	 * 
	 * <p><strong>NOTE:</strong> Any field marked as secure will not be included as
	 * part of the XML document</p>
	 * 
	 * @return An XML representation of the model as a <code>String</code>.
	 */
	public String toXMLString() {
		return("<field_type>" + 
			String.format("<id_field_type null=\"%b\">%s</id_field_type>", (this.getIdFieldType() == null), (this.getIdFieldType() != null ? this.getIdFieldType() : "")) + 
			String.format("<nm_field_type null=\"%b\">%s</nm_field_type>", (this.getNmFieldType() == null), (this.getNmFieldType() != null ? XmlHelper.escapeXml(this.getNmFieldType()) : "")) + 
			String.format("<fl_field_should_quote null=\"%b\">%s</fl_field_should_quote>", (this.getFlFieldShouldQuote() == null), (this.getFlFieldShouldQuote() != null ? this.getFlFieldShouldQuote() : "")) + 
			"</field_type>");
	}

}